### 101. [Copy List with Random Pointer](https://leetcode.com/problems/copy-list-with-random-pointer/)

**First Solution**

```python
"""
# Definition for a Node.
class Node:
    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):
        self.val = int(x)
        self.next = next
        self.random = random
"""

class Solution:
    def copyRandomList(self, head: 'Node') -> 'Node':
        if not head:
            return None
        dic_node = {}
        index = 0
        cur = head
        while cur:
            dic_node[cur] = index
            cur = cur.next
            index += 1
        newHead = Node(head.val)
        newcur = newHead
        cur = head
        list_node = []
        while cur:
            if cur.next:
                newcur.next = Node(cur.next.val)
            list_node.append(newcur)
            newcur = newcur.next
            cur = cur.next
        cur = head
        newcur = newHead
        while cur:
            if cur.random:
                newcur.random = list_node[dic_node[cur.random]]
            cur = cur.next
            newcur = newcur.next
        return newHead
```

* Time complexity: O(n)
* Space complexity: O(n)

**Second Solution***

```python
class Solution:
    def copyRandomList(self, head: 'Node') -> 'Node':
        dic = collections.defaultdict(lambda: Node(0))
        dic[None] = None
        cur = head
        while cur:
            dic[cur].val = cur.val
            dic[cur].next = dic[cur.next]
            dic[cur].random = dic[cur.random]
            cur = cur.next
        return dic[head] 
```

* Code from [**tusizi**](https://leetcode.com/problems/copy-list-with-random-pointer/discuss/43485/Clear-and-short-python-O(2n)-and-O(n)-solution).
* Time complexity: O(n)
* Space complexity: O(n)





### 102. [Rotate List](https://leetcode.com/problems/rotate-list/)

**First Solution**

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next

class Solution:
    def rotateRight(self, head: ListNode, k: int) -> ListNode:
        if not k or not head:
            return head
        length = 0
        cur = head
        while cur:
            length += 1
            cur = cur.next
        step = k % length
        if step == 0:
            return head
        index = 0
        cur = head
        while cur:
            if index == length - step:
                pre.next = None
                rst = cur
            pre = cur
            cur = cur.next
            index += 1
        pre.next = head
        return rst
```

* Time complexity: O(n)
* Space complexity: O(1)





### 103. [Single Element in a Sorted Array](https://leetcode.com/problems/single-element-in-a-sorted-array/)

**First Solution**

```python
class Solution:
    def singleNonDuplicate(self, nums: List[int]) -> int:
        if not nums:
            return None
        if len(nums) == 1:
            return nums[0]
        for i in range(0, len(nums), 2):
            if i+1 == len(nums):
                return nums[i]
            if nums[i] != nums[i+1]:
                return nums[i]
```

* Linear search.
* Time complexity: O(n)
* Space complexity: O(1)

**Second Solution**

```python
class Solution:
    def singleNonDuplicate(self, nums: List[int]) -> int:
        if not nums:
            return None
        length = len(nums)
        if length == 1:
            return nums[0]
        else:
            head = 0
            tail = length - 1
            while True:
                new_length = tail - head + 1
                if new_length == 1:
                    return nums[head]
                isEven = True if ((new_length-1)/2)%2 == 0 else False
                mid = int((head+tail)/2)
                if isEven:
                    if tail - head == 2:
                        if nums[mid] == nums[head]:
                            return nums[tail]
                        else:
                            return nums[head]
                    if nums[mid] == nums[mid+1]:
                        head = mid
                        continue
                    if nums[mid] == nums[mid-1]:
                        tail = mid
                        continue
                    return nums[mid]
                else:
                    if mid == head:
                        return nums[head]
                    if nums[mid] == nums[mid+1]:
                        tail = mid - 1
                        continue
                    if nums[mid] == nums[mid-1]:
                        head = mid + 1
                        continue
```

* Binary search.
* Time complexity: O(log(n))
* Space complexity: O(1)

**Third Solution***

```python
class Solution:
    def singleNonDuplicate(self, nums: List[int]) -> int:
        head, tail = 0, len(nums) - 1
        while head < tail:
            mid = int((head + tail) / 2)
            if nums[mid] == nums[mid ^ 1]: # mid xor 1
                head = mid + 1
            else:
                tail = mid
        return nums[head]
```

* Same idea as second solution.
* Code from [**StefanPochmann**](https://leetcode.com/problems/single-element-in-a-sorted-array/discuss/100732/Short-compare-numsi-with-numsi1).
* odd `xor` 1 = odd - 1
* even `xor` 1 = even + 1





### 104. [Connecting Graph](https://www.lintcode.com/problem/connecting-graph/description)

**First Solution**

```python
class ConnectingGraph:

    def __init__(self, n: int):
        self.data = [i for i in range(n)]

    def connect(self, a: int, b: int):
        root_a = self.find(a)
        root_b = self.find(b)
        if root_a != root_b:
            self.data[root_b] = root_a

    def query(self, a: int, b: int) -> bool:
        root_a = self.find(a)
        root_b = self.find(b)
        return root_a == root_b
        
    def find(self, a: int) -> int:
        a = a-1
        starter = a
        while self.data[a] != a:
            a = self.data[a]
        root = a
        while self.data[starter] != root:
            nxt = self.data[starter]
            self.data[starter] = root
            starter = nxt
        return root
```

* Union-Find with path compression.
* Time complexity: O(log* n) (O(n) for construction)
* Space complexity: O(n)





### 105. [Connecting Graph II](https://www.lintcode.com/problem/connecting-graph-ii/description)

**First Solution**

```python
class ConnectingGraph2:

    def __init__(self, n: int):
        self.data = [[i, 1] for i in range(n)]

    def connect(self, a: int, b: int):
        root_a = self.find(a)
        root_b = self.find(b)
        if root_a != root_b:
            self.data[root_b][0] = self.data[root_a][0]
            self.data[root_a][1] += self.data[root_b][1]

    def query(self, a: int) -> int:
        root = self.find(a)
        return self.data[root][1]
        
    def find(self, a: int) -> int:
        a = a - 1
        starter = a
        while self.data[a][0] != a:
            a = self.data[a][0]
        root = a
        while self.data[a][0] != root:
            nxt = self.data[starter][0]
            self.data[starter][0] = root
            self.data[root][1] += 1
            starter = nxt
        return root
```

* Similiar as #104.
* Time complexity: O(log* n) (O(n) for construction)
* Space complexity: O(n)





### 106. [Connecting Graph III](https://www.lintcode.com/problem/connecting-graph-iii/description)

**First Solution**

```python
class ConnectingGraph3:

    def __init__(self, n: int):
        self.data = [i for i in range(n)]
        self.connectedComponent = n
    
    def connect(self, a: int, b: int):
        root_a = self.find(a)
        root_b = self.find(b)
        if root_a != root_b:
            self.data[root_b] = self.data[root_a]
            self.connectedComponent -= 1

    def query(self) -> int:
        return self.connectedComponent
        
    def find(self, a: int) -> int:
        a = a - 1
        starter = a
        while self.data[a] != a:
            a = self.data[a]
        root = a
        while starter != self.data[starter]:
            nxt = self.data[starter]
            self.data[starter] = root
            starter = nxt
        return root
```

* Similar as #104.
* Time complexity: O(log* n) (O(n) for construction)
* Space complexity: O(n)





### 107. [Remove K Digits](https://leetcode.com/problems/remove-k-digits/)

**First Solution***

```python
class Solution:
    def removeKdigits(self, num: str, k: int) -> str:
        rst = []
        for d in num:
            while k and rst and rst[-1] > d:
                rst.pop()
                k -= 1
            rst.append(d)
        return ''.join(rst[:-k or None]).lstrip('0') or '0'
```

* Code from [**StefanPochmann**](https://leetcode.com/problems/remove-k-digits/discuss/88668/Short-Python-one-O(n)-and-one-RegEx): Go through the digit from left to right, remove it if this is a peak digit(a digit on the left is bigger than the right one).
* Time complexity: O(n)
* Space complexity: O(n)





### 108. [Number of Islands II](https://leetcode.com/problems/number-of-islands-ii/)

**First Solution**

```python
class DisjointSet:
    def __init__(self, size: int):
        self.data = [i for i in range(size)]
        self.numSet = size
    
    def find(self, tar: int) -> int:
        tmp = tar
        while self.data[tar] != tar:
            tar = self.data[tar]
        root = tar
        while self.data[tmp] != root:
            nxt = self.data[tmp]
            self.data[tmp] = root
            tmp = nxt
        return root
        
    def union(self, a: int, b: int):
        rootA = self.find(a)
        rootB = self.find(b)
        if rootA != rootB:
            self.data[rootB] = rootA
            self.numSet -= 1
            
    def getSetNum(self) -> int:
        return self.numSet

class Solution:
    def translatePos(self, m: int, n: int, size: List[int]) -> int:
        return int(n + m * size[1])
    
    def findIsland(self, m: int, n: int, islandMap: List[List[int]], size: List[int]) -> List[int]:
        rtn = []
        if 0 <= m - 1 and islandMap[m-1][n] == 1:
            rtn.append([m-1, n])
        if m + 1 < size[0] and islandMap[m+1][n] == 1:
            rtn.append([m+1, n])
        if 0 <= n - 1 and islandMap[m][n-1] == 1:
            rtn.append([m, n-1])
        if n + 1 < size[1] and islandMap[m][n+1] == 1:
            rtn.append([m, n+1])
        return rtn
    
    def numIslands2(self, m: int, n: int, positions: List[List[int]]) -> List[int]:
        size = [m, n, m*n]
        islandMap = [[0 for i in range(n)] for j in range(m)]
        islandSet = DisjointSet(m*n)
        numPos = 0
        rtn = []
        while positions:
            pos = positions.pop(0)
            if islandMap[pos[0]][pos[1]] == 1:
                rtn.append(rtn[-1])
                continue
            islandPos = self.findIsland(pos[0], pos[1], islandMap, size)
            if islandPos:
                for island in islandPos:
                    islandSet.union(
                        self.translatePos(pos[0], pos[1], size), 
                        self.translatePos(island[0], island[1], size))
            islandMap[pos[0]][pos[1]] = 1
            numPos += 1
            rtn.append(numPos-size[2]+islandSet.getSetNum())
        return rtn
```

* Self-defined **Disjoint Set**;
* Keep track of set numbers in disjoint set, compute island number in each round.
* Time complexity: O(k\*log(m\*n)), where k is the length of the `positions`
* Space complexity: O(m\*n)





### 109. [Implement Trie (Prefix Tree)](https://leetcode.com/problems/implement-trie-prefix-tree/)

**First Solution**

```python
class Trie:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.data = {}

    def insert(self, word: str) -> None:
        """
        Inserts a word into the trie.
        """
        cur = self.data
        for char in word:
            if char not in cur:
                cur[char] = {}
            cur = cur[char]
        cur['word'] = True

    def search(self, word: str) -> bool:
        """
        Returns if the word is in the trie.
        """
        cur = self.data
        for char in word:
            if char in cur:
                cur = cur[char]
            else:
                return False
        if 'word' in cur:
            return True
        return False

    def startsWith(self, prefix: str) -> bool:
        """
        Returns if there is any word in the trie that starts with the given prefix.
        """
        cur = self.data
        for char in prefix:
            if char in cur:
                cur = cur[char]
            else:
                return False
        if cur:
            return True
        else:
            return False


# Your Trie object will be instantiated and called as such:
# obj = Trie()
# obj.insert(word)
# param_2 = obj.search(word)
# param_3 = obj.startsWith(prefix)
```

* Trie structure implemented by dictionary.
* Time complexity: O(n)
* Space complexity: O(n) (O(1) for search)





### 110. [Graph Valid Tree](https://leetcode.com/problems/graph-valid-tree/)

**First Solution**

```python
class DisjointSet:
    def __init__(self, size: int):
        self.data = [i for i in range(size)]
        self.numSet = size
        
    def find(self, tar: int) -> int:
        tmp = tar
        while self.data[tar] != tar:
            tar = self.data[tar]
        root = tar
        while self.data[tmp] != root:
            nxt = self.data[tmp]
            self.data[tmp] = root
            tmp = nxt
        return root
    
    def union(self, a: int, b: int) -> bool:
        rootA = self.find(a)
        rootB = self.find(b)
        if rootA != rootB:
            self.data[rootB] = rootA
            self.numSet -= 1
            return True
        return False

class Solution:
    def validTree(self, n: int, edges: List[List[int]]) -> bool:
        if not edges:
            if n == 1:
                return True
            return False
        if len(edges) >= n:
            return False
        disjointSet = DisjointSet(n)
        for edge in edges:
            if not disjointSet.union(edge[0], edge[1]):
                return False
        if disjointSet.numSet == 1:
            return True
        return False
```

* Self-defined **Disjoint Set**, make sure there's only one set exist.
* If `num_edge > num_node - 1`, then it can not form a tree.
* Time complexity: O(n)
* Space complexity: O(n)





### 111. [Accounts Merge](https://leetcode.com/problems/accounts-merge/)

**First Solution**

```python
class DisjointSet:
    def __init__(self, size: int):
        self.data = [i for i in range(size)]
        
    def find(self, tar: int) -> int:
        tmp = tar
        while self.data[tar] != tar:
            tar = self.data[tar]
        root = tar
        while self.data[tmp] != root:
            nxt = self.data[tmp]
            self.data[tmp] = root
            tmp = nxt
        return root
    
    def union(self, a: int, b: int):
        rootA = self.find(a)
        rootB = self.find(b)
        if rootA != rootB:
            self.data[rootB] = rootA  

class Solution:
    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:
        sets = DisjointSet(len(accounts))
        dic_account = {}
        rtn = []
        for i in range(len(accounts)):
            for j in range(1, len(accounts[i])):
                if accounts[i][j] not in dic_account:
                    dic_account[accounts[i][j]] = i
                else:
                    sets.union(dic_account[accounts[i][j]], i)
        dic_join = {}
        d = sets.data
        for k in dic_account.keys():
            index = sets.find(sets.data[dic_account[k]])
            if index not in dic_join:
                dic_join[index] = []
            dic_join[index].append(k)
        for k in dic_join.keys():
            name = [accounts[k][0]]
            email = sorted(dic_join[k])
            rtn.append(name+email)
        return rtn
```

* Self-defined **Disjoint Set**;
* First do union-find, then rejoin those emails. Be careful about the repeated names, since we can not use name as dictionary keys.
* Time complexity: O(n)
* Space complexity: O(n)





### 112. [Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray/)

**First Solution***

```python
class Solution:
    def maxSubarraySumCircular(self, A: List[int]) -> int:
        if len(A) == 0:
            return 0
        maxTotal,maxSoFar,minSoFar,minTotal,s = A[0], A[0], A[0], A[0],A[0]
        for i in range(1, len(A)):
            maxSoFar = max(A[i], maxSoFar + A[i])
            maxTotal = max(maxTotal, maxSoFar)                 
            minSoFar = min(A[i], minSoFar + A[i])            
            minTotal = min(minTotal, minSoFar)            
            s += A[i]
        if(s == minSoFar):
            return maxTotal
        return max(s - minTotal, maxTotal)
```

* Solution from [**logan138**](https://leetcode.com/problems/maximum-sum-circular-subarray/discuss/633058/Java-or-C%2B%2B-or-Python3-or-With-detailed-explanation-or-O(N)-time-or-O(1)).
  1. Find maximum subarray sum using Kadane's algorithm (max);
  2. Find minimum subarray sum using Kadane's algorithm (min);
  3. Find total sum of the array (sum);
  4. Now, if sum == min, return max;
  5. Otherwise, return maximum(max, sum - min).
* Based on Dynamic Programming.





### 113. [Add and Search Word - Data structure design](https://leetcode.com/problems/add-and-search-word-data-structure-design/)

**First Solution**

```python
class TrieNode:
    def __init__(self, size):
        self.next = [None for _ in range(size)]
        self.isWord = False
        self.size = size
            

class WordDictionary:
    def __init__(self):
        self.trie = TrieNode(26)
        
    def addWord(self, word: str) -> None:
        cur = self.trie
        for char in word:
            index = ord(char) - 97 # ord('a')
            if not cur.next[index]:
                cur.next[index] = TrieNode(cur.size)
            cur = cur.next[index]
        cur.isWord = True
        
    def search(self, word: str) -> bool:
        cur = self.trie
        i = 0
        stack = []
        while i <= len(word):
            n = cur.next
            if i == len(word):
                if cur.isWord:
                    return True
                else:
                    if stack:
                        nxt, i = stack.pop()
                        cur = nxt
                        i += 1
                        continue
                    else:
                        return False
            if word[i] == '.':
                for nxt in cur.next:
                    if nxt:
                        stack.append([nxt, i])
                if stack:
                    nxt, i = stack.pop()
                    cur = nxt
                    i += 1
                else:
                    return False
            else:
                index = ord(word[i]) - 97
                nxt = cur.next[index]
                if nxt:
                    cur = nxt
                    i += 1
                else:
                    if stack:
                        nxt, i = stack.pop()
                        cur = nxt
                        i += 1
                    else:
                        return False


# Your WordDictionary object will be instantiated and called as such:
# obj = WordDictionary()
# obj.addWord(word)
# param_2 = obj.search(word)
```

* Self-defined Trie.
* Time complexity: O(nlog(n))
* Space complexity: O(n)

**Second Solution***

```python
class TrieNode():
    def __init__(self):
        self.children = collections.defaultdict(TrieNode)
        self.isWord = False
    
class WordDictionary(object):
    def __init__(self):
        self.root = TrieNode()

    def addWord(self, word):
        node = self.root
        for w in word:
            node = node.children[w]
        node.isWord = True

    def search(self, word):
        node = self.root
        self.res = False
        self.dfs(node, word)
        return self.res
    
    def dfs(self, node, word):
        if not word:
            if node.isWord:
                self.res = True
            return 
        if word[0] == ".":
            for n in node.children.values():
                self.dfs(n, word[1:])
        else:
            node = node.children.get(word[0])
            if not node:
                return 
            self.dfs(node, word[1:])
```

* Code from [**caikehe**](https://leetcode.com/problems/add-and-search-word-data-structure-design/discuss/59725/Python-easy-to-follow-solution-using-Trie.).
* Self-defined Trie, use defaultdict as child link. Recursive DFS to search.





### 114. [Word Squares](https://leetcode.com/problems/word-squares/)

**First Solution**

```python
class TrieNode:
    def __init__(self):
        self.child = {}
        self.isWord = False
        
class Trie:
    def __init__(self):
        self.data = TrieNode()
        
    def insert(self, word: str):
        cur = self.data
        for char in word:
            if char not in cur.child:
                cur.child[char] = TrieNode()
            cur = cur.child[char]
        cur.isWord = True
        
    def search(self, word: str) -> bool:
        cur = self.data
        for char in word:
            if char not in cur.child:
                return False
            cur = cur.child[char]
        return cur.isWord
    
    def getWord(self, word: str) -> List[str]:
        rtn = []
        cur = self.data
        for char in word:
            if char in cur.child:
                cur = cur.child[char]
            else:
                return []
        stack = []
        level = 0
        for d in cur.child:
            stack.append([d, cur.child[d], level])
        tmp = ''
        while stack:
            char, node, level = stack.pop()
            tmp = tmp[:level]
            tmp += char
            if node.isWord:
                rtn.append(word+tmp)
            for d in node.child:
                stack.append([d, node.child[d], level+1])
        return rtn 
        

class Solution:
    def wordSquares(self, words: List[str]) -> List[List[str]]:
        if len(words[0]) == 1:
            rtn = []
            for word in words:
                rtn.append([word])
            return rtn
        trie = Trie()
        for word in words:
            trie.insert(word)
        rtn = []
        mtx = []
        for word in words:
            mtx.append(word)
            pool = []
            j = 1
            while j <= len(words[0]):
                if j == len(words[0]):
                    if mtx:
                        if mtx not in rtn:
                            rtn.append(mtx[:])
                        tmp.pop()
                        if tmp:
                            t = mtx[:-1]
                            for p in tmp:
                                t.append(p)
                                rtn.append(t)
                    if pool:
                        p, j = pool.pop()
                        dif = len(mtx) - j
                        for _ in range(dif):
                            mtx.pop()
                        mtx.append(p)
                        j += 1
                        continue
                    else:
                        break
                key = ''
                for i in range(j):
                    key += mtx[i][j]
                tmp = trie.getWord(key)
                if tmp:
                    for t in tmp:
                        pool.append([t, j])
                if pool:
                    p, j = pool.pop()
                    dif = len(mtx) - j
                    for _ in range(dif):
                        mtx.pop()
                    mtx.append(p)
                    j += 1
                else:
                    mtx = []
                    break
            mtx = []
            tmp = []
            pool = []
        rst = []
        for r in rtn:
            if len(r) == len(words[0]):
                rst.append(r)
        return rst
```

* Self-defined Trie.
* Super slow, but very good at space.
* I coded this in sort of backtracking way but not efficient. This question should be revisit using backtracking + trie.

**Second Solution***

```python
class Solution:

    def wordSquares(self, words: List[str]) -> List[List[str]]:

        self.words = words
        self.N = len(words[0])
        self.buildTrie(self.words)

        results = []
        word_squares = []
        for word in words:
            word_squares = [word]
            self.backtracking(1, word_squares, results)
        return results

    def buildTrie(self, words):
        self.trie = {}

        for wordIndex, word in enumerate(words):
            node = self.trie
            for char in word:
                if char in node:
                    node = node[char]
                else:
                    newNode = {}
                    newNode['#'] = []
                    node[char] = newNode
                    node = newNode
                node['#'].append(wordIndex)

    def backtracking(self, step, word_squares, results):
        if step == self.N:
            results.append(word_squares[:])
            return

        prefix = ''.join([word[step] for word in word_squares])
        for candidate in self.getWordsWithPrefix(prefix):
            word_squares.append(candidate)
            self.backtracking(step+1, word_squares, results)
            word_squares.pop()

    def getWordsWithPrefix(self, prefix):
        node = self.trie
        for char in prefix:
            if char not in node:
                return []
            node = node[char]
        return [self.words[wordIndex] for wordIndex in node['#']]
```

* Code from [LeetCode Solution](https://leetcode.com/problems/word-squares/solution/)

**Third Solution**

```python
class TrieNode:
    def __init__(self):
        self.child = {}
        self.words = []
        self.isWord = False
        
class Trie:
    def __init__(self):
        self.node = TrieNode()
    
    def insert(self, word: str):
        cur = self.node
        for char in word:
            if char not in cur.child:
                cur.child[char] = TrieNode()
            cur.words.append(word)
            cur = cur.child[char]
        cur.isWord = True
        
    def search(self, word: str) -> bool:
        cur = self.node
        for char in word:
            if char not in cur.child:
                return False
            cur = cur.child[char]
        return cur.isWord
    
    def startWith(self, prefix: str) -> List[str]:
        cur = self.node
        for char in prefix:
            if char not in cur.child:
                return []
            cur = cur.child[char]
        return cur.words

class Solution:
    def wordSquares(self, words: List[str]) -> List[List[str]]:
        if not words:
            return []
        trie = Trie()
        for word in words:
            trie.insert(word)    
        rtn = []
        for word in words:
            mtx = [word]
            self.backtracking(1, mtx, trie, rtn)
        return rtn
            
    def backtracking(self, step: int, mtx: List[str], trie: Trie, rtn: List[List[str]]):
        if step == len(mtx[0]):
            rtn.append(mtx[:])
            return
        prefix = ''.join([word[step] for word in mtx])
        for candidate in trie.startWith(prefix):
            mtx.append(candidate)
            self.backtracking(step+1, mtx, trie, rtn)
            mtx.pop()
```

* Self-defined Trie with backtracking.





### 115. [Find All Anagrams in a String](https://leetcode.com/problems/find-all-anagrams-in-a-string/)

**First Solution**

```python
class Solution:
    def findAnagrams(self, s: str, p: str) -> List[int]:
        if not s or not p:
            return []
        dicP = {}
        lenP = len(p)
        for char in p:
            if char not in dicP:
                dicP[char] = 1
            else:
                dicP[char] += 1
        rtn = []
        for j in range(len(s)-lenP+1):
            if self.inDic(s[j:j+lenP], dicP.copy()):
                rtn.append(j)
        return rtn
    
    def inDic(self, s: str, d: dict) -> bool:
        for c in s:
            if c not in d or d[c] == 0:
                return False
            d[c] -= 1
        return True
```

* **Time Limit Exceeded**
* Hash-table with string compare.
* Time complexity: O(mn), where m is len(s) and n is len(p)
* Space complexity: O(n)

**Second Solution***

```python
from collections import Counter

class Solution:
    def findAnagrams(self, s: str, p: str) -> List[int]:
        ns, np = len(s), len(p)
        if ns < np:
            return []
        pc = Counter(p)
        sc = Counter()
        rtn = []
        for i in range(ns):
            sc[s[i]] += 1
            if i >= np:
                if sc[s[i-np]] == 1:
                    del sc[s[i-np]]
                else:
                    sc[s[i-np]] -= 1
            if pc == sc:
                rtn.append(i-np+1)
        return rtn
```

* Solution from [LeetCode Solution](https://leetcode.com/problems/find-all-anagrams-in-a-string/solution/)
* Time complexity: O(m+n) where m is len(s) and n is len(p)
* Space complexity: O(1) (Because it's at most 26, hence constant space.)





### 116. [4Sum](https://leetcode.com/problems/4sum/)

**First Solution***

```python
class Solution:
    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:
        def findNsum(nums, target, N, result, results):
            if len(nums) < N or N < 2 or target < nums[0]*N or target > nums[-1]*N:  # early termination
                return
            if N == 2: # two pointers solve sorted 2-sum problem
                l,r = 0,len(nums)-1
                while l < r:
                    s = nums[l] + nums[r]
                    if s == target:
                        results.append(result + [nums[l], nums[r]])
                        l += 1
                        while l < r and nums[l] == nums[l-1]:
                            l += 1
                    elif s < target:
                        l += 1
                    else:
                        r -= 1
            else: # recursively reduce N
                for i in range(len(nums)-N+1):
                    if i == 0 or (i > 0 and nums[i-1] != nums[i]):
                        findNsum(nums[i+1:], target-nums[i], N-1, result+[nums[i]], results)

        results = []
        findNsum(sorted(nums), target, 4, [], results)
        return results
```

* Code from [**zhuyinghua1203**](https://leetcode.com/problems/4sum/discuss/8545/Python-140ms-beats-100-and-works-for-N-sum-(Ngreater2))
* The core is to implement a fast 2-pointer to solve 2-sum, and recursion to reduce the N-sum to 2-sum.
* Some optimization was be made knowing the list is sorted.





### 117. [Permutation in String](https://leetcode.com/problems/permutation-in-string/)

**First Solution**

```python
from collections import Counter

class Solution:
    def checkInclusion(self, s1: str, s2: str) -> bool:
        l1, l2 = len(s1), len(s2)
        if l2 < l1:
            return False
        c1 = Counter(s1)
        c2 = Counter()
        for i in range(l2):
            if s2[i] not in c2:
                c2[s2[i]] = 1
            else:
                c2[s2[i]] += 1
            if i >= l1:
                if c2[s2[i-l1]] == 1:
                    del c2[s2[i-l1]]
                else:
                    c2[s2[i-l1]] -= 1
            if c1 == c2:
                return True
        return False
```

* Same idea as #115 second solution: Sliding Window with Counter
* Time complexity: O(n)
* Space complexity: O(1)





### 118. [Word Search II](https://leetcode.com/problems/word-search-ii/)

**First Solution**

```python
class TrieNode:
    def __init__(self):
        self.child = {}
        self.words = set()
        self.isWord = False
        
class Trie:
    def __init__(self):
        self.node = TrieNode()
        
    def insert(self, word: str):
        cur = self.node
        for char in word:
            if char not in cur.child:
                cur.child[char] = TrieNode()
            cur.words.add(word)
            cur = cur.child[char]
        cur.isWord = True
        
    def search(self, word: str) -> bool:
        cur = self.node
        for char in word:
            if char not in cur.child:
                return False
            cur = cur.child[char]
        return cur.isWord
    
    def startWith(self, prefix: str) -> bool:
        cur = self.node
        for char in prefix:
            if char not in cur.child:
                return False
            cur = cur.child[char]
        return True

class Solution:
    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:
        if not words or not board:
            return []
        self.trie = Trie()
        self.maxStep = 0
        for word in words:
            self.trie.insert(word)
            self.maxStep = max(self.maxStep, len(word))
        self.board = board
        self.rtn = set()
        for i in range(len(self.board)):
            for j in range(len(self.board[0])):
                if self.trie.startWith(self.board[i][j]):
                    path = [[0 for n in range(len(self.board[0]))] for m in range(len(self.board))]
                    self.backtracking(1, [i, j], self.board[i][j], path)
        return list(self.rtn)
        
    def explore(self, pos: List[int], path: List[List[int]]):
        rtn = []
        if 0 <= pos[0] - 1 and path[pos[0]-1][pos[1]] == 0:
            rtn.append([pos[0]-1, pos[1]])
        if pos[0] + 1 < len(self.board) and path[pos[0]+1][pos[1]] == 0:
            rtn.append([pos[0]+1, pos[1]])
        if 0 <= pos[1] - 1 and path[pos[0]][pos[1]-1] == 0:
            rtn.append([pos[0], pos[1]-1])
        if pos[1] + 1 < len(self.board[0]) and path[pos[0]][pos[1]+1] == 0:
            rtn.append([pos[0], pos[1]+1])
        return rtn
        
    def backtracking(self, step: int, pos: List[int], word: str, path: List[List[int]]):
        if step > self.maxStep:
            return
        if self.trie.search(word):
            self.rtn.add(word)
        path[pos[0]][pos[1]] = 1
        candidates = self.explore(pos, path)
        if candidates:
            for candidate in candidates:
                if self.trie.startWith(word+self.board[candidate[0]][candidate[1]]):
                    self.backtracking(step+1, candidate, word+self.board[candidate[0]][candidate[1]], path)
                    path[candidate[0]][candidate[1]] = 0
```

* Backtracking with Trie.
* Time performance is not good. Probably because path need to rebuild each time being used. This should be easily solved by change path as pass-by-value state. However, I couldn't figure out how to do that.

**Second Solution**

```python
class TrieNode:
    def __init__(self):
        self.child = {}
        self.words = set()
        self.isWord = False
        
class Trie:
    def __init__(self):
        self.node = TrieNode()
        
    def insert(self, word: str):
        cur = self.node
        for char in word:
            if char not in cur.child:
                cur.child[char] = TrieNode()
            cur.words.add(word)
            cur = cur.child[char]
        cur.isWord = True
        
    def search(self, word: str) -> bool:
        cur = self.node
        for char in word:
            if char not in cur.child:
                return False
            cur = cur.child[char]
        return cur.isWord
    
    def startWith(self, prefix: str) -> bool:
        cur = self.node
        for char in prefix:
            if char not in cur.child:
                return False
            cur = cur.child[char]
        return True

class Solution:
    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:
        if not words or not board:
            return []
        self.trie = Trie()
        self.maxStep = 0
        for word in words:
            self.trie.insert(word)
            self.maxStep = max(self.maxStep, len(word))
        self.board = board
        self.rtn = set()
        for i in range(len(self.board)):
            for j in range(len(self.board[0])):
                if self.trie.startWith(self.board[i][j]):
                    visited = set()
                    self.backtracking(1, [i, j], self.board[i][j], visited)
        return list(self.rtn)
    
    def explore(self, pos: List[int], path: set):
        rtn = []
        if 0 <= pos[0] - 1 and str(pos[0]-1)+'#'+str(pos[1]) not in path:
            rtn.append([pos[0]-1, pos[1]])
        if pos[0] + 1 < len(self.board) and str(pos[0]+1)+'#'+str(pos[1]) not in path:
            rtn.append([pos[0]+1, pos[1]])
        if 0 <= pos[1] - 1 and str(pos[0])+'#'+str(pos[1]-1) not in path:
            rtn.append([pos[0], pos[1]-1])
        if pos[1] + 1 < len(self.board[0]) and str(pos[0])+'#'+str(pos[1]+1) not in path:
            rtn.append([pos[0], pos[1]+1])
        return rtn
    
    def backtracking(self, step: int, pos: List[int], word: str, path: set):
        if step > self.maxStep:
            return
        if self.trie.search(word):
            self.rtn.add(word)
        path.add(str(pos[0])+'#'+str(pos[1]))
        candidates = self.explore(pos, path)
        if candidates:
            for candidate in candidates:
                if self.trie.startWith(word+self.board[candidate[0]][candidate[1]]):
                    self.backtracking(step+1, candidate, word+self.board[candidate[0]][candidate[1]], path)
                    path.remove(str(candidate[0])+'#'+str(candidate[1]))
```

* Same idea as first solution, but changed `path(List[List[int]])` to `visited(set)`, decode pos as `str(pos[0])+'#'+str(pos[1])`. However, the time performance decreased.





### 119. []()

