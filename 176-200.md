### 176. [Paint House III](https://leetcode.com/problems/paint-house-iii/)

**First Solution***

```python
class Solution:
    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:
        # maps (i, t, p) -> the minimum cost to paint houses i <= h < m with t neighborhoods, where house i - 1 is color p
        dp = {}
        
        @functools.lru_cache(None)
        def dfs(i, t, p):
            key = (i, t, p)
            
            if i == len(houses) or t < 0:
                # base case - we're trying to color 0 houses. Also catches the case where we accidentally
                # color in too many neighborhoods before or at the end of the array. t<0 isn't necesssary
                # to check here, but it prunes a little bit of the search space to make things slightly faster.
                return 0 if t == 0 else float('inf')
            
            if key not in dp:
                if houses[i] == 0:
                    dp[key] = min(dfs(i + 1, t - (nc != p), nc) + cost[i][nc - 1] for nc in range(1, n + 1))
                else:
                    dp[key] = dfs(i + 1, t - (houses[i] != p), houses[i])
                
            return dp[key]
            
        ret = dfs(0, target, -1)
        # if ret is infinity, then we failed every case because there were too many neighborhoods
        # to start. If we could paint over houses that were previously painted, we could remedy that,
        # but the problem doesn't allow that. so, we return -1 in that case.
        return ret if ret < float('inf') else -1
```

* Code from [**grawlixes**](https://leetcode.com/problems/paint-house-iii/discuss/674313/Simple-Python-explanation-and-why-I-prefer-top-down-DP-to-bottom-up)
* Dynamic Programming.
* Time Complexity: O(MN^2T) where M is m, N is n and T is size of target.
* Space Complexity: O(MNT)





### 177. [Is Subsequence](https://leetcode.com/problems/is-subsequence/)

**First Solution**

```python
class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        if not s:
            return True
        if not t:
            return False
        ps = pt = 0
        while pt < len(t):
            if s[ps] == t[pt]:
                ps += 1
            pt += 1
            if ps == len(s):
                return True
        return False
```

* Two pointer techniques.
* Time Complexity: O(N) N is the length of t.
* Space Complexity: O(1)

**Second Solution***

```python
class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        source_len, target_len = len(s), len(t)

        # the source string is empty
        if source_len == 0:
            return True

        # matrix to store the history of matches/deletions
        dp = [ [0] * (target_len + 1) for _ in range(source_len + 1)]

        # DP compute, we fill the matrix column by column, bottom up
        for col in range(1, target_len + 1):
            for row in range(1, source_len + 1):
                if s[row - 1] == t[col - 1]:
                    # find another match
                    dp[row][col] = dp[row - 1][col - 1] + 1
                else:
                    # retrieve the maximal result from previous prefixes
                    dp[row][col] = max(dp[row][col - 1], dp[row - 1][col])

            # check if we can consume the entire source string,
            #   with the current prefix of the target string.
            if dp[source_len][col] == source_len:
                return True

        return False
```

* Solution from [LeetCode Solution](https://leetcode.com/problems/is-subsequence/solution/)
* Dynamic Programming.
* Time Complexity: O(TS)
* Space Complexity: O(TS)





### 178. [Fruit Into Baskets](https://leetcode.com/problems/fruit-into-baskets/)

**First Solution***

```python
class Solution:
    def totalFruit(self, tree: List[int]) -> int:
        ans = i = 0
        count = collections.Counter()
        for j, x in enumerate(tree):
            count[x] += 1
            while len(count) >= 3:
                count[tree[i]] -= 1
                if count[tree[i]] == 0:
                    del count[tree[i]]
                i += 1
            ans = max(ans, j - i + 1)
        return ans
```

* Solution from [LeetCode Solution](https://leetcode.com/problems/fruit-into-baskets/solution/)
* Sliding window.
* Time Complexity: O(N)
* Space Complexity: O(N)





### 179. [Unique Paths II](https://leetcode.com/problems/unique-paths-ii/)

**First Solution**

```python
class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
        dp = [[0 for j in range(len(obstacleGrid[0]))] for i in range(len(obstacleGrid))]
        dp[0][0] = 1
        for i in range(len(obstacleGrid)):
            for j in range(len(obstacleGrid[0])):
                if obstacleGrid[i][j] == 1:
                    dp[i][j] = 0
                    continue
                if i > 0:
                    dp[i][j] += dp[i-1][j]
                if j > 0:
                    dp[i][j] += dp[i][j-1]
        return dp[-1][-1]
```

* Dynamic Programming Bottom-up w/o rolling array.
* Time Complexity: O(MN)
* Space Complexity: O(MN)

**Second Solution**

```python
class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
        dp = [[0 for j in range(len(obstacleGrid[0]))] for i in range(2)]
        dp[0][0] = 1
        cur = 1
        for i in range(len(obstacleGrid)):
            pre = cur
            cur = 1 - pre
            for j in range(len(obstacleGrid[0])):
                if obstacleGrid[i][j] == 1:
                    dp[cur][j] = 0
                    dp[pre][j] = 0
                    continue
                if i > 0:
                    dp[cur][j] += dp[pre][j]
                if j > 0:
                    dp[cur][j] += dp[cur][j-1]
                dp[pre][j] = 0
        return dp[cur][-1]
```

* Dynamic Programming Bottom-up w/ rolling array.
* Time Complexity: O(MN)
* Space Complexity: O(M)

**Third Solution**

```python
from functools import lru_cache

class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
        m, n = len(obstacleGrid), len(obstacleGrid[0])
        
        @lru_cache(None)
        def dp(m, n):
            if obstacleGrid[m-1][n-1] == 1:
                return 0
            if m == 1 and n == 1:
                return 1
            total = 0
            if m > 1:
                total += dp(m-1, n)
            if n > 1:
                total += dp(m, n-1)
            return total
        
        return dp(m, n)
```

* Dynamic Programming Top-down.
* Time Complexity: O(MN)
* Space Complexity: O(MN)





### 180. [Search Insert Position](https://leetcode.com/problems/search-insert-position/)

**First Solution**

```python
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        if not nums:
            return 0
        head, tail = 0, len(nums) - 1
        while head < tail:
            mid = (head + tail) // 2
            if target < nums[head]:
                return head
            if target > nums[tail]:
                return tail + 1
            if nums[mid] == target:
                return mid
            if head == mid:
                return tail
            if nums[mid] > target:
                tail = mid
                continue
            head = mid
        if nums[head] >= target:
            return 0
        else:
            return tail + 1
```

* Binary search.
* Time Complexity: O(logN)
* Space Complexity: O(1)

**Second Solution***

```python
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums) - 1
        while left <= right:
            pivot = (left + right) // 2
            if nums[pivot] == target:
                return pivot
            if target < nums[pivot]:
                right = pivot - 1
            else:
                left = pivot + 1
        return left
```

* Same idea, code from [LeetCode Solution](https://leetcode.com/problems/search-insert-position/solution/)

* Time Complexity: O(logN)
* Space Complexity: O(1)





### 181. [Unique Paths III](https://leetcode.com/problems/unique-paths-iii/)

**First Solution**

```python
class Solution:
    def uniquePathsIII(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        numSpace = m * n
        self.ans = 0
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 1:
                    start = [i, j]
                if grid[i][j] == 2:
                    end = [i, j]
                if grid[i][j] == -1:
                    numSpace -= 1
                    
        def dp(x, y, direction, visited):
            if x < 0 or y < 0 or x >= m or y >= n or (x == end[0] and y == end[1]):
                return
            if grid[x][y] == -1:
                return
            if x == start[0] and y == start[1] and visited == numSpace:
                self.ans += 1
                return
            grid[x][y] = -1
            if x > 0 and direction != 'down':
                dp(x-1, y, 'up', visited + 1)
            if x < m-1 and direction != 'up':
                dp(x+1, y, 'down', visited + 1)
            if y > 0 and direction != 'right':
                dp(x, y-1, 'left', visited + 1)
            if y < n-1 and direction != 'left':
                dp(x, y+1, 'right', visited + 1)
            grid[x][y] = 0
        
        dp(end[0], end[1] - 1, 'left', 2)
        dp(end[0], end[1] + 1, 'right', 2)
        dp(end[0] - 1, end[1], 'up', 2)
        dp(end[0] + 1, end[1], 'down', 2)
        
        return self.ans
```

* Not very efficient.
* Backtracking with DFS.
* Time Complexity: O(4^(RC))
* Space Complexity: O(RC)

**Second Solution***

```python
class Solution:
    def uniquePathsIII(self, grid: List[List[int]]) -> int:
        self.res = 0
        m, n,empty = len(grid), len(grid[0]),1
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 1: x,y = (i, j)
                elif grid[i][j] == 2: end = (i, j)
                elif grid[i][j] == 0: empty += 1
        def dfs(x, y, empty):
            if not (0 <= x < m and 0 <= y < n and grid[x][y] >= 0): return
            if (x, y) == end:
                self.res += empty == 0
                return
            grid[x][y] = -2
            dfs(x + 1, y, empty - 1)
            dfs(x - 1, y, empty - 1)
            dfs(x, y + 1, empty - 1)
            dfs(x, y - 1, empty - 1)
            grid[x][y] = 0
        dfs(x,y, empty)
        return self.res
```

* Solution from [**lee215**](https://leetcode.com/problems/unique-paths-iii/discuss/221946/JavaPython-Brute-Force-Backstracking)
* Same algorithm with first solution.





### 182. [Sort Colors](https://leetcode.com/problems/sort-colors/)

**First Solution**

```python
class Solution:
    def sortColors(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        counter = [0, 0, 0]
        for n in nums:
            counter[n] += 1
        tmp = 0
        for i in range(counter[0]):
            nums[i] = 0
        tmp += counter[0]
        for i in range(tmp, tmp + counter[1]):
            nums[i] = 1
        tmp += counter[1]
        for i in range(tmp, tmp + counter[2]):
            nums[i] = 2
```

* Counting sort.
* Time Complexity: O(N)
* Space Complexity: O(1)

**Second Solution***

```python
class Solution:
    def sortColors(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        p0 = cur = 0
        p2 = len(nums) - 1
        while cur <= p2:
            if nums[cur] == 0:
                nums[p0], nums[cur] = nums[cur], nums[p0]
                p0 += 1
                cur += 1
            elif nums[cur] == 2:
                nums[cur], nums[p2] = nums[p2], nums[cur]
                p2 -= 1
            else:
                cur += 1
```

* Solution from [LeetCode Solution](https://leetcode.com/problems/sort-colors/solution/)

* [Dutch National Flag Problem](https://en.wikipedia.org/wiki/Dutch_national_flag_problem) (Three pointers)
* Time Complexity: O(N)
* Space Complexity: O(1)





### 183. [Group Anagrams](https://leetcode.com/problems/group-anagrams/)

**First Solution**

```python
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        dic = {}
        for s in strs:
            asciiVal = self.getAscii(s)
            if asciiVal not in dic:
                dic[asciiVal] = [s]
            else:
                dic[asciiVal].append(s)
        return list(dic.values())
        
    def getAscii(self, strs: str) -> int:
        ans = 0
        for char in strs:
            ans += ord(char)
        return ans
```

* 32 / 101 cases passed.
* Use Ascii Code to sort.
* Time Complexity: O(N)
* Space Complexity: O(N)

**Second Solution**

```python
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        dic = {}
        for s in strs:
            sortedList = sorted(s)
            sortedStr = ''
            for char in sortedList:
                sortedStr += char
            if sortedStr not in dic:
                dic[sortedStr] = [s]
            else:
                dic[sortedStr].append(s)
        return list(dic.values())
```

* Sort every strings.

* Time Complexity: O(KNlogN) 

  where N is `len(strs)` and K is `max(len(str) for str in strs)`

* Space Complexity: O(KN)





### 184. [Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/)

**First Solution**

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        ans = 0
        for i in range(len(prices)-1):
            diff = prices[i+1] - prices[i]
            if diff > 0:
                ans += diff
        return ans
```

* Sum all increasing intervals.
* Time Complexity: O(N)
* Space Complexity: O(1)





### 185. [Counting Elements](https://leetcode.com/problems/counting-elements/)

**First Solution**

```python
class Solution:
    def countElements(self, arr: List[int]) -> int:
        pool = set(arr)
        ans = 0
        for a in arr:
            if a+1 in pool:
                ans += 1
        return ans
```

* Linear search with Hashset.
* Time Complexity: O(N)
* Space Complexity: O(N)

**Second Solution***

```python
def countElements(self, arr: List[int]) -> int:
    arr.sort()
    count = 0
    run_length = 1
    for i in range(len(arr)):
        if arr[i - 1] != arr[i]:
            if arr[i - 1] + 1 == arr[i]:
                count += run_length
            run_length = 0
        run_length += 1
    return count
```

* Solution from [LeetCode Solution](https://leetcode.com/problems/counting-elements/solution/)
* Linear search on a sorted array.
* Time Complexity: O(NlogN)
* Space Complexity: O(1)





### 186. [Middle of the Linked List](https://leetcode.com/problems/middle-of-the-linked-list/)

**First Solution**

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def middleNode(self, head: ListNode) -> ListNode:
        slow = fast = head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
        return slow
```

* Fast-slow pointers.
* Time Complexity: O(N)
* Space Complexity: O(1)





### 187. [Insert Delete GetRandom O(1)](https://leetcode.com/problems/insert-delete-getrandom-o1/)

**First Solution**

```python
class RandomizedSet:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.data = []
        self.map = {}
        import random
        

    def insert(self, val: int) -> bool:
        """
        Inserts a value to the set. Returns true if the set did not already contain the specified element.
        """
        if val not in self.map:
            self.map[val] = len(self.data)
            self.data.append(val)
            return True
        return False
        

    def remove(self, val: int) -> bool:
        """
        Removes a value from the set. Returns true if the set contained the specified element.
        """
        if val in self.map:
            index, last = self.map[val], self.data[-1]
            self.data[index], self.map[last] = last, index
            self.data.pop()
            self.map.pop(val, 0)
            return True
        return False
        

    def getRandom(self) -> int:
        """
        Get a random element from the set.
        """
        return self.data[random.randint(0, len(self.data) - 1)]
        

# Your RandomizedSet object will be instantiated and called as such:
# obj = RandomizedSet()
# param_1 = obj.insert(val)
# param_2 = obj.remove(val)
# param_3 = obj.getRandom()
```

* Time Complexity: O(1)
* Space Complexity: O(N)





### 188. [Last Stone Weight](https://leetcode.com/problems/last-stone-weight/)

**First Solution**

```python
class Solution:
    def lastStoneWeight(self, stones: List[int]) -> int:
        L = len(stones)
        if L == 1:
            return stones[0]
        if L == 0:
            return 0
        val1 = max(stones)
        stones.remove(val1)
        val2 = max(stones)
        stones.remove(val2)
        if val1 > val2:
            stones.append(val1 - val2)
        elif val1 < val2:
            stones.append(val2 - val1)
        return self.lastStoneWeight(stones)
```

* Simple Recursion.

* Time Complexity: O(N^2)
* Space Complexity: O(N^2)

**Second Solution***

```python
class Solution:
    def lastStoneWeight(self, stones: List[int]) -> int:
        
        # Set up the bucket array.
        max_weight = max(stones)
        buckets = [0] * (max_weight + 1)

        # Bucket sort.
        for weight in stones:
            buckets[weight] += 1

        # Scan through the weights.
        biggest_weight = 0 
        current_weight = max_weight
        while current_weight > 0:
            if buckets[current_weight] == 0:
                current_weight -= 1
            elif biggest_weight == 0:
                buckets[current_weight] %= 2
                if buckets[current_weight] == 1:
                    biggest_weight = current_weight
                current_weight -= 1
            else:
                buckets[current_weight] -= 1
                if biggest_weight - current_weight <= current_weight:
                    buckets[biggest_weight - current_weight] += 1
                    biggest_weight = 0
                else:
                    biggest_weight -= current_weight
        return biggest_weight
```

* Counting sort with bucket.

* Time Complexity: O(N+M)

  where N is `len(stones)` and M is `max(stones)`.

* Space Complexity: O(M)





### 189. [Largest Divisible Subset](https://leetcode.com/problems/largest-divisible-subset/)

**First Solution***

```python
class Solution:
    def largestDivisibleSubset(self, nums: List[int]) -> List[int]:
        if not nums:
            return []
        nums.sort()
        L = len(nums)
        dp = [0 for _ in range(L + 1)]
        for i in range(L):
            if nums[i] == 1:
                dp[i+1] = dp[i] + 1
                continue
            cur = 1
            for j in range(i):
                if nums[i] % nums[j] == 0:
                    cur = max(cur, dp[j+1])
            dp[i+1] = cur + 1
        maxSize = max(dp)
        maxIndex = dp.index(maxSize) - 1
        # ideas from LeetCode Solution
        curSize = maxSize
        curTail = nums[maxIndex]
        ans = []
        for i in range(maxIndex, -1, -1):
            if curSize == dp[i+1] and curTail % nums[i] == 0:
                ans.append(nums[i])
                curSize -= 1
                curTail = nums[i]
        return ans[::-1]
```

* Partial ideas from [LeetCode Solution](https://leetcode.com/problems/largest-divisible-subset/solution/)
* Dynamic Programming.
* Time Complexity: O(N^2)
* Space Complexity: O(N)

**Second Solution***

```python
class Solution:
    def largestDivisibleSubset(self, nums: List[int]) -> List[int]:
        
        def EDS(i):
            """ recursion with memoization """
            if i in memo:
                return memo[i]
            
            tail = nums[i]
            maxSubset = []
            # The value of EDS(i) depends on it previous elements
            for p in range(0, i):
                if tail % nums[p] == 0:
                    subset = EDS(p)
                    if len(maxSubset) < len(subset):
                        maxSubset = subset
            
            # extend the found max subset with the current tail.
            maxSubset = maxSubset.copy()
            maxSubset.append(tail)
            
            # memorize the intermediate solutions for reuse.
            memo[i] = maxSubset
            return maxSubset
        
        # test case with empty set
        if len(nums) == 0: return []
        
        nums.sort()
        memo = {}
    
        # Find the largest divisible subset
        return max([EDS(i) for i in range(len(nums))], key=len)
```

* Solution from [LeetCode Solution](https://leetcode.com/problems/largest-divisible-subset/solution/)

* Time Complexity: O(N^2)
* Space Complexity: O(N^2)





### 190. [Perform String Shifts](https://leetcode.com/problems/perform-string-shifts/)

**First Solution**

```python
class Solution:
    def stringShift(self, s: str, shift: List[List[int]]) -> str:
        step = 0
        for sh in shift:
            if sh[0] == 0:
                step += sh[1]
            else:
                step -= sh[1]
        step %= len(s)
        return s[step:]+s[:step]
```

* Time Complexity: O(N+M)

  where N is `len(s)` and M is `len(shift)`.

* Space Complexity: O(N)





### 191. [Cheapest Flights Within K Stops](https://leetcode.com/problems/cheapest-flights-within-k-stops/)

**First Solution***

```python
import heapq

class Solution:
    
    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, K: int) -> int:
        
        # Build the adjacency matrix
        adj_matrix = [[0 for _ in range(n)] for _ in range(n)]
        for s, d, w in flights:
            adj_matrix[s][d] = w
            
        # Shortest distances array
        distances = [float("inf") for _ in range(n)]
        current_stops = [float("inf") for _ in range(n)]
        distances[src], current_stops[src] = 0, 0
        
        # Data is (cost, stops, node)
        minHeap = [(0, 0, src)]     
        
        while minHeap:
            
            cost, stops, node = heapq.heappop(minHeap)
            
            # If destination is reached, return the cost to get here
            if node == dst:
                return cost
            
            # If there are no more steps left, continue 
            if stops == K + 1:
                continue
             
            # Examine and relax all neighboring edges if possible 
            for nei in range(n):
                if adj_matrix[node][nei] > 0:
                    dU, dV, wUV = cost, distances[nei], adj_matrix[node][nei]
                    
                    # Better cost?
                    if dU + wUV < dV:
                        distances[nei] = dU + wUV
                        heapq.heappush(minHeap, (dU + wUV, stops + 1, nei))
                    elif stops < current_stops[nei]:
                        
                        #  Better steps?
                        current_stops[nei] = stops
                        heapq.heappush(minHeap, (dU + wUV, stops + 1, nei))
            
        return -1 if distances[dst] == float("inf") else distances[dst]
```

* Dijkstra's Algorithm. Solution from [LeetCode Solution](https://leetcode.com/problems/cheapest-flights-within-k-stops/solution/)

* Time Complexity: O(V^2*logV)
* Space Complexity: O(V^2)

**Second Solution***

```python
class Solution:
    
    def __init__(self):
        self.adj_matrix = None
        self.memo = {}
    
    def findShortest(self, node, stops, dst, n):
            
        # No need to go any further if the destination is reached    
        if node == dst:
            return 0
        
        # Can't go any further if no stops left
        if stops < 0:
            return float("inf")
        
        # If the result of this state is already cached, return it
        if (node, stops) in self.memo:
            return self.memo[(node, stops)]
        
        # Recursive calls over all the neighbors
        ans = float("inf")
        for neighbor in range(n):
            if self.adj_matrix[node][neighbor] > 0:
                ans = min(ans, self.findShortest(neighbor, stops-1, dst, n) + self.adj_matrix[node][neighbor])
        
        # Cache the result
        self.memo[(node, stops)] = ans        
        return ans
    
    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, K: int) -> int:
        
        self.adj_matrix = [[0 for _ in range(n)] for _ in range(n)]
        self.memo = {}
        for s, d, w in flights:
            self.adj_matrix[s][d] = w
        
        result = self.findShortest(src, K, dst, n)
        return -1 if result == float("inf") else result
```

* DFS with Memorization. Solution from [LeetCode Solution](https://leetcode.com/problems/cheapest-flights-within-k-stops/solution/)

* Time Complexity: O(KV^2)
* Space Complexity: O(VK+V^2)

**Third Solution***

```python
class Solution:
    
    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, K: int) -> int:
        
        # We use two arrays for storing distances and keep swapping
        # between them to save on the memory
        distances = [[float('inf')] * n for _ in range(2)]
        distances[0][src] = distances[1][src] = 0
        
        # K + 1 iterations of Bellman Ford
        for iterations in range(K + 1):
            
            # Iterate over all the edges
            for s, d, wUV in flights:
                
                # Current distance of node "s" from src
                dU = distances[1 - iterations&1][s]
                
                # Current distance of node "d" from src
                # Note that this will port existing values as
                # well from the "previous" array if they didn't already exist
                dV = distances[iterations&1][d]
                
                # Relax the edge if possible
                if dU + wUV < dV:
                    distances[iterations&1][d] = dU + wUV
                    
        return -1 if distances[K&1][dst] == float("inf") else distances[K&1][dst]
```

* Bellman-Ford Algorithm. Solution from [LeetCode Solution](https://leetcode.com/problems/cheapest-flights-within-k-stops/solution/)

* Time Complexity: O(KE)

* Space Complexity: O(V)

**Fourth Solution***

```python
class Solution:
    
    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, K: int) -> int:
        
        # Build the adjacency matrix
        adj_matrix = [[0 for _ in range(n)] for _ in range(n)]
        for s, d, w in flights:
            adj_matrix[s][d] = w
            
        # Shortest distances dictionary
        distances = {}
        distances[(src, 0)] = 0
        
        # BFS Queue
        bfsQ = deque([src])
        
        # Number of stops remaining
        stops = 0
        ans = float("inf")
        
        # Iterate until we exhaust K+1 levels or the queue gets empty
        while bfsQ and stops < K + 1:
            
            # Iterate on current level
            length = len(bfsQ)
            for _ in range(length):
                node = bfsQ.popleft()
                
                # Loop over neighbors of popped node
                for nei in range(n):
                    if adj_matrix[node][nei] > 0:
                        dU = distances.get((node, stops), float("inf"))
                        dV = distances.get((nei, stops + 1), float("inf"))
                        wUV = adj_matrix[node][nei]
                        
                        # No need to update the minimum cost if we have already exhausted our K stops. 
                        if stops == K and nei != dst:
                            continue
                        
                        if dU + wUV < dV:
                            distances[nei, stops + 1] = dU + wUV
                            bfsQ.append(nei)
                            
                            # Shortest distance of the destination from the source
                            if nei == dst:
                                ans = min(ans, dU + wUV)
            stops += 1   
        
        return -1 if ans == float("inf") else ans
```

* BFS. Solution from [LeetCode Solution](https://leetcode.com/problems/cheapest-flights-within-k-stops/solution/)
* Time Complexity: O(EK)
* Space Complexity: O(V^2+VK)





### 192. [Diameter of Binary Tree](https://leetcode.com/problems/diameter-of-binary-tree/)

**First Solution**

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def diameterOfBinaryTree(self, root: TreeNode) -> int:
        if not root:
            return 0
        self.maxDiameter = 0
        
        def DFS(root):
            if not root:
                return -1
            l = DFS(root.left) + 1
            r = DFS(root.right) + 1
            self.maxDiameter = max(self.maxDiameter, l + r)
            return max(l, r)
        
        a = DFS(root)
        return self.maxDiameter
```

* Time Complexity: O(N)
* Space Complexity: O(N)





### 193. [Search in a Binary Search Tree](https://leetcode.com/problems/search-in-a-binary-search-tree/)

**First Solution**

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def searchBST(self, root: TreeNode, val: int) -> TreeNode:
        if not root:
            return None
        if root.val == val:
            return root
        if root.val < val:
            return self.searchBST(root.right, val)
        else:
            return self.searchBST(root.left, val)
```

* Time Complexity: O(logN)

* Space Complexity: O(logN)





### 194. [Validate IP Address](https://leetcode.com/problems/validate-ip-address/)

**First Solution**

```python
class Solution:
    def validIPAddress(self, IP: str) -> str:
        for char in IP:
            if char == '.':
                return self.isIPv4(IP + '.')
            elif char == ':':
                return self.isIPv6(IP + ':')
        return 'Neither'
            
    def isIPv4(self, IP: str) -> str:
        pool = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'}
        tmp = ''
        num_dots = 0
        for num in IP:
            if num == '.':
                if tmp and tmp == str(int(tmp)) and 0 <= int(tmp) <= 255:
                    tmp = ''
                    num_dots += 1
                    continue
                else:
                    return 'Neither'
            elif num in pool:
                tmp += num
            else:
                return 'Neither'
        if num_dots != 4:
            return 'Neither'
        return 'IPv4'
        
    def isIPv6(self, IP: str) -> str:
        pool = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
                'a', 'b', 'c', 'd', 'e', 'f',
                'A', 'B', 'C', 'D', 'E', 'F'}
        ctr = 0
        num_colons = 0
        for char in IP:
            if char == ':' and 0 < ctr <= 4:
                ctr = 0
                num_colons += 1
                continue
            elif char in pool:
                ctr += 1
                continue
            else:
                return 'Neither'
        if num_colons != 8:
            return 'Neither'
        return 'IPv6'
```

* Straight-forward if-else solution.

* Time Complexity: O(N)

* Space Complexity: O(1)

  Constant time but similar to N.

**Second Solution***

```python
def validIPAddress(self, IP):
        
        def isIPv4(s):
            try: return str(int(s)) == s and 0 <= int(s) <= 255
            except: return False
            
        def isIPv6(s):
            if len(s) > 4: return False
            try: return int(s, 16) >= 0 and s[0] != '-'
            except: return False

        if IP.count(".") == 3 and all(isIPv4(i) for i in IP.split(".")): 
            return "IPv4"
        if IP.count(":") == 7 and all(isIPv6(i) for i in IP.split(":")): 
            return "IPv6"
        return "Neither"
```

* Solution from [**lee215**](https://leetcode.com/problems/validate-ip-address/discuss/95484/PythonJava-Easy-Understand-Solution)
* Time Complexity: O(N)
* Space Complexity: O(N)





### 195. [Surrounded Regions](https://leetcode.com/problems/surrounded-regions/)

**First Solution**

```python
class Solution:
    def solve(self, board: List[List[str]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """
        if not board:
            return
        lx, ly = len(board), len(board[0])
        def dfs(x, y):
            board[x][y] = 'B'
            if 0 <= x-1 and board[x-1][y] == 'O':
                dfs(x-1, y)
            if 0 <= y-1 and board[x][y-1] == 'O':
                dfs(x, y-1)
            if x+1 <= lx-1 and board[x+1][y] == 'O':
                dfs(x+1, y)
            if y+1 <= ly-1 and board[x][y+1] == 'O':
                dfs(x, y+1)
                
        for i in range(lx):
            if board[i][0] == 'O':
                dfs(i, 0)
            if board[i][ly-1] == 'O':
                dfs(i, ly-1)
                
        for j in range(ly):
            if board[0][j] == 'O':
                dfs(0, j)
            if board[lx-1][j] == 'O':
                dfs(lx-1, j)

        for i in range(lx):
            for j in range(ly):
                if board[i][j] == 'O':
                    board[i][j] = 'X'
                if board[i][j] == 'B':
                    board[i][j] = 'O'
```

* DFS

* Time Complexity: O(N)

  Where N is the number of cells.

* Space Complexity: O(N)





### 196. [H-Index](https://leetcode.com/problems/h-index/)

**First Solution**

```python
import heapq

class Solution:
    def hIndex(self, citations: List[int]) -> int:
        ans = 1
        cHeap = [c * -1 for c in citations]
        heapify(cHeap) # O(N)
        for _ in range(len(cHeap)):
            c = heappop(cHeap) # O(logN)
            if -1 * c >= ans:
                ans += 1
            else:
                break
        return ans - 1
```

* Heap and counting.
* Time Complexity: O(N)
* Space Complexity: O(N)





### 197. [H-Index II](https://leetcode.com/problems/h-index-ii/)

**First Solution**

```python
class Solution:
    def hIndex(self, citations: List[int]) -> int:
        L = len(citations)
        head, tail = 0, L - 1
        while head <= tail:
            mid = (head + tail) // 2
            if citations[mid] >= L - mid:
                tail = mid - 1
            else:
                head = mid + 1
        return L - head
```

* Binary search.
* Time Complexity: O(logN)
* Space Complexity: O(1)





### 198. [Longest Repeating Substring](https://leetcode.com/problems/longest-repeating-substring/)

**First Solution**

```python
class Solution:
    def longestRepeatingSubstring(self, S: str) -> int:
        L = len(S)
        for n in range(L - 1, -1, -1):
            pool = set()
            for i in range(L - n + 1):
                if S[i:i+n] not in pool:
                    pool.add(S[i:i+n])
                else:
                    return n
        return 0
```

* Time Complexity: O(N^2K)

  where N is `len(S)` and K is `len(ans)`

* Space Complexity: O(NK)

* Detailed explanation see [LeetCode Solution](https://leetcode.com/problems/longest-repeating-substring/solution/)





### 199. [Longest Duplicate Substring](https://leetcode.com/problems/longest-duplicate-substring/)

**First Solution**

```python
class Solution:
    def longestDupSubstring(self, S: str) -> str:
        L = len(S)
        for n in range(L - 1, -1, -1):
            pool = set()
            for i in range(L - n + 1):
                if S[i:i+n] not in pool:
                    pool.add(S[i:i+n])
                else:
                    return S[i:i+n]
        return ''
```

* This is a follow up question of #198.

* Time Limit Exceeded.

* Time Complexity: O(N^2K)

  where N is `len(S)` and K is `len(ans)`

* Space Complexity: O(NK)

**Second Solution***

```python
class Solution:
    def search(self, L: int, a: int, modulus: int, n: int, nums: List[int]) -> str:
        """
        Rabin-Karp with polynomial rolling hash.
        Search a substring of given length
        that occurs at least 2 times.
        @return start position if the substring exits and -1 otherwise.
        """
        # compute the hash of string S[:L]
        h = 0
        for i in range(L):
            h = (h * a + nums[i]) % modulus
              
        # already seen hashes of strings of length L
        seen = {h} 
        # const value to be used often : a**L % modulus
        aL = pow(a, L, modulus) 
        for start in range(1, n - L + 1):
            # compute rolling hash in O(1) time
            h = (h * a - nums[start - 1] * aL + nums[start + L - 1]) % modulus
            if h in seen:
                return start
            seen.add(h)
        return -1
        
    def longestDupSubstring(self, S: str) -> str:
        n = len(S)
        # convert string to array of integers
        # to implement constant time slice
        nums = [ord(S[i]) - ord('a') for i in range(n)]
        # base value for the rolling hash function
        a = 26
        # modulus value for the rolling hash function to avoid overflow
        modulus = 2**32
        
        # binary search, L = repeating string length
        left, right = 1, n
        while left <= right:
            L = left + (right - left) // 2
            if self.search(L, a, modulus, n, nums) != -1:
                left = L + 1
            else:
                right = L - 1
               
        start = self.search(left - 1, a, modulus, n, nums)
        return S[start: start + left - 1]
```

* Solution from [LeetCode Solution](https://leetcode.com/problems/longest-duplicate-substring/solution/)

* Time Complexity: O(NlogN)
* Space Complexity: O(N)





### 200. [Dungeon Game](https://leetcode.com/problems/dungeon-game/)

**First Solution***

```python
class Solution(object):
    def calculateMinimumHP(self, dungeon):
        """
        :type dungeon: List[List[int]]
        :rtype: int
        """
        rows, cols = len(dungeon), len(dungeon[0])
        dp = [[float('inf')] * cols for _ in range(rows)]

        def get_min_health(currCell, nextRow, nextCol):
            if nextRow >= rows or nextCol >= cols:
                return float('inf')
            nextCell = dp[nextRow][nextCol]
            # hero needs at least 1 point to survive
            return max(1, nextCell - currCell)

        for row in reversed(range(rows)):
            for col in reversed(range(cols)):
                currCell = dungeon[row][col]

                right_health = get_min_health(currCell, row, col+1)
                down_health = get_min_health(currCell, row+1, col)
                next_health = min(right_health, down_health)

                if next_health != float('inf'):
                    min_health = next_health
                else:
                    min_health = 1 if currCell >= 0 else (1 - currCell)

                dp[row][col] = min_health

        return dp[0][0]
```

* Dynamic Programming

* Time Complexity: O(MN)

  M is the `len(dungeon)` and N is the `len(dungeon[0])`

* Space Complexity: O(MN)