### 76. [Two Sum II - Input array is sorted](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/)

**First Solution**

```python
class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        if not numbers and not target:
            return []
        head = 0
        tail = len(numbers)-1
        while numbers[head]+numbers[tail] != target:
            if numbers[head]+numbers[tail] > target:
                tail -= 1
            else:
                head += 1
        return [head+1, tail+1]
```





### 77. [First Unique Character in a String](https://leetcode.com/problems/first-unique-character-in-a-string/)

**First Solution**

```python
class Solution:
    def firstUniqChar(self, s: str) -> int:
        if not s:
            return -1
        d = {}
        for char in s:
            if char not in d:
                d[char] = 1
            else:
                d[char] += 1
        for i in range(len(s)):
            if d[s[i]] == 1:
                return i
        return -1
```





### 78. [Max Consecutive Ones](https://leetcode.com/problems/max-consecutive-ones/)

**First Solution**

```python
class Solution:
    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:
        if not nums:
            return 0
        rst = [0]
        pre = False
        for n in nums:
            if n == 1:
                if pre:
                    rst[-1] += 1
                else:
                    rst.append(1)
                pre = True
            else:
                pre = False
        return max(rst)
```





### 79. [Minimum Size Subarray Sum](https://leetcode.com/problems/minimum-size-subarray-sum/)

**First Solution**

```python
class Solution:
    def minSubArrayLen(self, s: int, nums: List[int]) -> int:
        if not s or not nums:
            return 0
        slow = 0
        fast = 0
        total = 0
        minval = len(nums)+1
        while fast < len(nums):
            total += nums[fast]
            fast += 1
            while total >= s:
                minval = min(minval, fast-slow)
                total -= nums[slow]
                slow += 1
        return 0 if minval == len(nums)+1 else minval
```

Notes:

* Time complexity: O(n);
* Two-pointer technique: fast & slow points.





### 80. [Majority Element](https://leetcode.com/problems/majority-element/)

**First Solution**

```python
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        element = {}
        length = len(nums)
        if length == 1:
            return nums[0]
        limit = length/2
        for n in nums:
            if n in element:
                element[n] += 1
                if element[n] > limit:
                    return n
            else:
                element[n] = 1
```

**Second Solution***

```python
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        major = nums[0]
        ctr = 1
        for n in range(1, len(nums)):
            if ctr == 0:
                ctr += 1
                major = nums[n]
            elif major == nums[n]:
                ctr += 1
            else:
                ctr -= 1
        return major
```

Notes:

* [Boyer-Moore Majority Vote Algorithm](http://www.cs.utexas.edu/~moore/best-ideas/mjrty/);
* Time complexity: O(n);
* Space complexity: O(1).





### 81. [Rotate Array](https://leetcode.com/problems/rotate-array/)

**First Solution***

```python
class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        length = len(nums)
        step = k % length
        tmp = [0] * length
        for i in range(length):
            tmp[(i+step)%length] = nums[i]
        nums[:] = tmp
```

Notes:

* Using extra array;
* Time complexity: O(n);
* Space complexity: O(n).

**Second Solution***

```python
class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        length = len(nums)
        step = k % length
        start = 0
        count = 0
        while count < length:
            cur, pre = start, nums[start]
            while True:
                nxt = (cur + step) % length
                nums[nxt], pre = pre, nums[nxt]
                cur = nxt
                count += 1
                if start == cur:
                    break
            start += 1
```

Notes:

* Cyclic replacement;
* Time complexity: O(n);
* Space complexity: O(1).

**Third Solution***

```python
class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        def reverse(nums, start, end):
            while start < end:
                nums[start], nums[end] = nums[end], nums[start]
                start, end = start+1, end-1
        
        length = len(nums)
        step = k % length
        reverse(nums, 0, length - 1)
        reverse(nums, 0, step - 1)
        reverse(nums, step, length - 1)
```

Notes:

* Double reverse;
* Time complexity: O(n);
* Space complexity: O(1).





### 82. [Cousins in Binary Tree](https://leetcode.com/problems/cousins-in-binary-tree/)

**First Solution**

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isCousins(self, root: TreeNode, x: int, y: int) -> bool:
        if not root or not x or not y:
            return None
        level = [root]
        while level:
            index = []
            for i in range(len(level)):
                if level[i] and level[i].val in [x, y]:
                    index.append(i)
            if len(index) == 2:
                index.sort()
                if not (index[0] + 1 == index[1] and index[0]%2 == 0):
                    return True
            tmp = []
            for node in level:
                if node:
                    tmp.extend([node.left, node.right])
            level = tmp
        return False
```

Notes:

* BFS;
* Examine *x* and *y* in the same level and exclude the situation of two nodes having same parent.

**Second Solution**

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isCousins(self, root: TreeNode, x: int, y: int) -> bool:
        def dfs(node, parent, depth, mod):
            if node:
                if node.val == mod:
                    return depth, parent
                return dfs(node.left, node, depth + 1, mod) or dfs(node.right, node, depth + 1, mod)
        dx, px, dy, py = dfs(root, None, 0, x) + dfs(root, None, 0, y)
        return dx == dy and px != py
```

Notes:

* DFS;
* Two round: find *x* and find *y*;
* Compare depth and parent.





### 83. [Pascal's Triangle II](https://leetcode.com/problems/pascals-triangle-ii/)

**First Solution**

```python
class Solution:
    def getRow(self, rowIndex: int) -> List[int]:
        row = [1]
        for i in range(rowIndex):
            row = self.buildPascal(row)
        return row
    
    def buildPascal(self, row: List[int]) -> List[int]:
        tmp = [1]
        for i in range(len(row)-1):
            tmp.append(row[i]+row[i+1])
        tmp.append(1)
        return tmp
```

Notes:

* Time complexity: O(2^k)
* Space complexity: O(k)





### 84. [Reverse Words in a String](https://leetcode.com/problems/reverse-words-in-a-string/)

**First Solution**

```python
class Solution:
    def reverseWords(self, s: str) -> str:
        if not s:
            return ''
        list_s = s.split()[::-1]
        string_s = ''
        for l in list_s:
            string_s += (l+' ')
        return string_s[:len(string_s)-1]
```





### 85. [Reverse Words in a String III](https://leetcode.com/problems/reverse-words-in-a-string-iii/)

**First Solution**

```python
class Solution:
    def reverseWords(self, s: str) -> str:
        if not s:
            return ''
        list_s = s.split()
        string_s = ''
        for l in list_s:
            string_s += l[::-1]
            string_s += ' '
        return string_s[:len(string_s)-1]
```

**Second Solution***

```python
class Solution:
    def reverseWords(self, s: str) -> str:
        return ' '.join(x[::-1] for x in s.split())
```

Notes:

* Same idea as first solution;
* Code from [**StefanPochmann**](https://leetcode.com/problems/reverse-words-in-a-string-iii/discuss/101909/1-line-Ruby-Python).





### 86. [Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/)

**First Solution**

```python
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        slow = 0
        for fast in range(len(nums)):
            if nums[fast] > nums[slow]:
                slow += 1
                nums[slow], nums[fast] = nums[fast], nums[slow]
        nums = nums[:slow+1]
        return len(nums)
```

Notes:

* Two-pointer technique;
* Time complexity: O(n);
* Space complexity: O(1).





### 87. [Design Linked List](https://leetcode.com/problems/design-linked-list/)

**First Solution**

```python
class MyLinkedList:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.val = None
        self.next = None

    def get(self, index: int) -> int:
        """
        Get the value of the index-th node in the linked list. If the index is invalid, return -1.
        """
        cur = 0
        while cur < index:
            cur += 1
            if not self.next:
                return -1
            self = self.next
        return self.val

    def addAtHead(self, val: int) -> None:
        """
        Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.
        """
        if self.val is None:
            self.val = val
            return
        node = MyLinkedList()
        node.val = self.val
        node.next = self.next
        self.val = val
        self.next = node

    def addAtTail(self, val: int) -> None:
        """
        Append a node of value val to the last element of the linked list.
        """
        node = MyLinkedList()
        node.val = val
        while self.next:
            self = self.next
        self.next = node

    def addAtIndex(self, index: int, val: int) -> None:
        """
        Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted.
        """
        if index == 0:
            self.addAtHead(val)
            return
        cur = 0
        while cur < index-1:
            if not self.next:
                return
            self = self.next
            cur += 1
        node = MyLinkedList()
        node.val = val
        if self.next:
            node.next = self.next
            self.next = node
        else:
            self.next = node
            
    def deleteAtIndex(self, index: int) -> None:
        """
        Delete the index-th node in the linked list, if the index is valid.
        """
        if index == 0:
            if self.next is not None:
                self.val = self.next.val
                self.next = self.next.next
                return
            else:
                self.val = None
                return
        cur = 0
        while cur < index-1:
            if not self.next:
                return
            self = self.next
            cur += 1
        if self.next:
            self.next = self.next.next


# Your MyLinkedList object will be instantiated and called as such:
# obj = MyLinkedList()
# param_1 = obj.get(index)
# obj.addAtHead(val)
# obj.addAtTail(val)
# obj.addAtIndex(index,val)
# obj.deleteAtIndex(index)
```

Notes:

* The idea is quite simple, but it's hard to consider all the test cases and to be bug-free.
* My solution here could be simplified, and frankly, it should be.





### 88. [Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/)

**First Solution**

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def hasCycle(self, head: ListNode) -> bool:
        if not head:
            return False
        fast = head
        slow = head
        while slow.next:
            if fast.next and fast.next.next:
                fast = fast.next.next
            else:
                return False
            slow = slow.next
            if fast == slow:
                return True
        return False
```

Notes:

* Fast-slow pointers to test linked list cycle.

**Second Solution***

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def hasCycle(self, head: ListNode) -> bool:
        try:
            slow = head
            fast = head.next
            while slow is not fast:
                slow = slow.next
                fast = fast.next.next
            return True
        except:
            return False
```

Notes:

* Code from [**StefanPochmann**](https://leetcode.com/problems/linked-list-cycle/discuss/44494/Except-ionally-fast-Python);
* Use `try-catch` statement to handle exceptions to avoid lots of `if` statements.





### 89. [Linked List Cycle II](https://leetcode.com/problems/linked-list-cycle-ii/)

**First Solution - Time Limit Exceeded**

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def detectCycle(self, head: ListNode) -> ListNode:
        if not head:
            return None
        slow = head
        while slow.next:
            dic_fast = {}
            fast = slow.next
            while fast and fast not in dic_fast:
                if fast is slow:
                    return slow
                dic_fast[fast] = True
                fast = fast.next
            slow = slow.next
        return None
```

Notes:

* Two-pointer technique;
* Time complexity: O(n!);
* Space complexity: O(1).

**Second Solution**

```python
class Solution:
    def detectCycle(self, head: ListNode) -> ListNode:
        dic_list = {}
        while head:
            if head not in dic_list:
                dic_list[head] = True
            else:
                return head
            head = head.next
        return None
```

Notes:

* Take hash-table to store the visited nodes;
* Time complexity: O(n);
* Space complexity: O(n).

**Third Solution***

```python
class Solution:
    def detectCycle(self, head: ListNode) -> ListNode:
        if not head:
            return None
        isLoop, joint = self.isAcyclic(head)
        if not isLoop:
            return None
        else:
            slow = head
            fast = joint
            while slow != fast:
                slow = slow.next
                fast = fast.next
            return slow
        
    def isAcyclic(self, head: ListNode):
        fast = head
        slow = head
        while slow.next:
            if fast.next and fast.next.next:
                fast = fast.next.next
            else:
                return False, None
            slow = slow.next
            if slow is fast:
                return True, slow
        return False, None
```

Notes:

* [Floyd's Tortoise and Hare](https://en.wikipedia.org/wiki/Cycle_detection#Floyd's_Tortoise_and_Hare);
* Time complexity: O(n);
* Space complexity: O(1).





### 90. []()